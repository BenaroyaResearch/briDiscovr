markerInfoInfileV2 <-
file.path(
DIR_DATA_SOURCE,
"Excel Files", "250416_MarkerInfoClusterVer2.xlsx")
markerInfoV2 <-
readxl::read_xlsx(markerInfoInfileV2) %>%
as.data.frame() %>%
remove_all_NA_rowcols()
markerInfoV2 <-
markerInfoV2 %>%
# drop duplicate rows
unique() %>%
mutate(
# fill in any gaps in fixed column
fixed =
case_when(
is.na(fixed) ~ desc,
TRUE ~ fixed)
)
# convert marker names to syntactically valid names
# this prevents issues with names not matching downstream
markerInfoV2$fixed <- make.names(markerInfoV2$fixed)
markerInfoOutcolsV2 <-
c("fixed", "desc", "useToCluster")
markerInfoOutfileV2 <-
file.path(
DIR_DATA_SAVED,
paste0("SLE_Sm_specific_B_cells_DISCOVR_marker_info_v2.", FILENAME_SUFFIX, ".csv"))
markerInfoV2 %>%
dplyr::select(all_of(markerInfoOutcolsV2)) %>%
write.csv(file = markerInfoOutfileV2, row.names = FALSE, na = "")
# Chunk 7: createFcsInfoFile
popsFcsFiles <- c("Sm neg FCS", "Sm pos FCS")
dirsFcsFiles <-
file.path(DIR_DATA_SOURCE, "250416 FCS Files", popsFcsFiles) %>%
setNames(popsFcsFiles)
filenameListsFcsFiles <-
list.files(dirsFcsFiles, pattern = "\\.fcs$")
fcsInfo <-
dataCytofAnnotation %>%
mutate(
filename =
case_when(
cellSubset == "Sm Tet-" ~ file.path(dirsFcsFiles[["Sm neg FCS"]], filename),
cellSubset == "Sm Tet+" ~ file.path(dirsFcsFiles[["Sm pos FCS"]], filename)) %>%
# convert to absolute path
normalizePath()) %>%
dplyr::select(
subject = donorId,
cellSubset,
filename) %>%
as.data.frame()
# get number of events for each file and each sample
fcsInfo <-
fcsInfo %>%
# calculate number of events per file
mutate(
nEvents = unlist(lapply(filename, briDiscovr:::getFcsNEvents))) %>%
# calculate number of events per sample
group_by(subject) %>%
mutate(nEventsPerSample = sum(nEvents)) %>%
ungroup()
# min(fcsInfo$nEvents) # minimum of 174 in the Sm Tet+, which is plenty to work with
# min(fcsInfo$nEventsPerSample) # minimum of 19892 events per sample
# sort(fcsInfo$nEvents / fcsInfo$nEventsPerSample) # max 4.6% are Sm Tet+, min of 95.4% are Sm Tet-
# # create a copy of each FCS file, with desc filled in for marker info (because briDiscovr needs it)
# for (i in 1:nrow(fcsInfo)) {
#   dir.tmp <- str_replace(fcsInfo$filename[i], "\\/[a-zA-Z0-9_\\-]+\\.fcs$", "")
#   if (!dir.exists(dir.tmp)) dir.create(dir.tmp)
#   if (!file.exists(fcsInfo$filename[i]) | OVERWRITE_EXISTING_INTERMEDIATES) {
#     fcs.tmp <- read.FCS(fcsInfo$filenameOrig[i])
#     fcs.tmp@parameters@data$desc <- fcs.tmp@parameters@data$name
#     flowCore::write.FCS(fcs.tmp, filename = fcsInfo$filename[i])
#   }
# }
# set rows of fcsInfo to include (use this to modify file inclusion)
# fcsInfoOutrows <- 1:nrow(fcsInfo)
# set rows of fcsInfo to a limited set for testing
# first identify subjects with all cell subset samples passing threshold, and keep all cell subsets for those subjects
nSamplesForTesting <- 10
set.seed(4321)
samplesForTesting <-
fcsInfo %>%
dplyr::filter(nEventsPerSample >= 32, nEvents > 0) %>%
group_by(subject) %>%
summarise(nCellSubsets = n()) %>%
dplyr::filter(nCellSubsets == n_distinct(fcsInfo$cellSubset)) %>%
sample_n(nSamplesForTesting) %>%
dplyr::pull(subject)
fcsInfoOutrows <-
which(fcsInfo$subject %in% samplesForTesting)
fcsInfoOutcols <-
c("subject", "cellSubset", "filename")
fcsInfoOutfile <-
file.path(
DIR_DATA_SAVED,
paste0("SLE_Sm_specific_B_cells_DISCOVR_fcs_info.", FILENAME_SUFFIX, ".csv"))
fcsInfo %>%
dplyr::slice(fcsInfoOutrows) %>%
dplyr::select(all_of(fcsInfoOutcols)) %>%
write.csv(file = fcsInfoOutfile, row.names = FALSE, na = "")
rm_tmp(ask = FALSE)
# Chunk 8: createDesignObject
# subject and cellSubset match the same fields in discovrSleBCells$fcsInfo and other components
design <-
fcsInfo %>%
# merge in clinical data (add here if needed)
left_join(
dataCytofAnnotation %>%
dplyr::select(-subject) %>%
dplyr::mutate(subject = donorId) %>%
dplyr::rename(filenameExPath = filename))
# Chunk 9: setupPopulationsForDiscovrExperiment
popParent <- "Sm Tet-"
# Chunk 10: setParamsDiscovr
nMetaclustersMax <- 40
minPercPerCluster <- 0.1
# Chunk 11: defineMakeMetaclusterZscoreHeatmapFunction
makeMetaclusterZscoreHeatmap <-
function(
experiment,
design, # object with additional sample annotation
childSubsets = NULL,
markers = "default", # default uses experiment$metaclusterMarkers; or specify a vector
zScoreBreaks = c(-2,0,2),
zScoreColors = c("#00FFFF", "#000000", "#FDE725"),
columnDendHeight = 10,
rowDendWidth = 10,
groupColumn = NULL, # optional group to include in annotation (can be FACS batch, comparison group, etc.)
groupColors = NULL, # use a named vector!
metaclusterColors = NULL, # use a named vector!
rowNameTranslator = NULL, # named vactor with desired rownames as elements and marker names as names
verbose = FALSE, # print out additional information
... # additional arguments passed to Heatmap
) {
# Check markers to plot
if (identical(markers, "default")) {
markers <- experiment$metaclusterMarkers
} else if (!all(markers %in% rownames(experiment$allSubsetAllSubjectZscores))) {
stop(
paste("The following markers to plot were not found in the discovrExperiment esperiment object:",
pander::p(setdiff(markers, experiment$metaclusterMarkers),
wrap = "")))
}
# Check requested subsets
subsets <- unique(experiment$fcsInfo$cellSubset)
parentSubset <- experiment$parentPopulation
if (is.null(childSubsets)){
childSubsets <- subsets[subsets != parentSubset]
message(
"No child populations specified. Assuming child populations are: ",
paste0(childSubsets, collapse = "; ")
)
}
# Display Parameters
titleFontParam = grid::gpar(fontface = "bold", fontsize = 15)
marker_label_gp = grid::gpar(fontsize = 13)
# Set up color palettes
if (is.null(metaclusterColors)) {
metaclusterColors <-
briDiscovr:::getColorList(experiment$kGroups) %>%
setNames(str_sort(as.character(unique(experiment$colIndices)), numeric=TRUE))
}
if (is.null(names(metaclusterColors)))
names(metaclusterColors) <- str_sort(as.character(unique(experiment$colIndices)), numeric=TRUE)
if (length(metaclusterColors) != experiment$kGroups){
stop("The length of 'metaclusterColors' must be the same as the number of metaclusters. ",
length(metaclusterColors), " colors were provided for ", experiment$kGroups, " metaclusters.")
}
if (!is.null(groupColumn) & (length(groupColors) == 0)) {
groupColors <-
briDiscovr:::getColorList(n_distinct(design[[groupColumn]])) %>%
setNames(levels(design[[groupColumn]]))
}
palZscores <- circlize::colorRamp2(
breaks = zScoreBreaks,
colors = zScoreColors
)
# set up zScoreLegend
zScoreMaxLabel = ifelse(
max(zScoreBreaks) < max(experiment$allSubsetAllSubjectZscores, na.rm = TRUE),
paste0("> ", max(zScoreBreaks)),
max(zScoreBreaks)
)
zScoreMinLabel = ifelse(
min(zScoreBreaks) > min(experiment$allSubsetAllSubjectZscores, na.rm = TRUE),
paste0("< ", min(zScoreBreaks)),
min(zScoreBreaks)
)
zScoreBreaks = sort(zScoreBreaks)
zScoreBreakLabels = zScoreBreaks
zScoreBreakLabels[1] = zScoreMinLabel
zScoreBreakLabels[length(zScoreBreakLabels)] = zScoreMaxLabel
zScoreLegendParam = list(
at = zScoreBreaks,
labels = zScoreBreakLabels
)
# get subject ids, assign colors to them
subjectIds <- sort(unique(experiment$clusterRarePopCts$samp))
subjectIdColors <- data.frame(
subject = subjectIds,
color = viridisLite::plasma(length(subjectIds), begin = 0.2)
)
## put together annotation
annoColumns <- c("subject", "metacluster", groupColumn, parentSubset, childSubsets)
allSubsetZscoreAnnoDf <-
experiment$hmapDfAllSubsets %>%
dplyr::select(.data$sampRpClust, !!subsets) %>%
unique %>%
dplyr::slice(match(colnames(experiment$allSubsetAllSubjectZscores), .data$sampRpClust)) %>%
dplyr::left_join(
data.frame(metacluster = experiment$colIndices) %>% rownames_to_column("sampRpClust"),
by = "sampRpClust"
) %>%
dplyr::mutate(
metacluster = metacluster %>%
as.character() %>%
factor(levels = str_sort(unique(.), numeric = TRUE)),
subject = str_replace(.data$sampRpClust, "_[0-9]+$", ""))
# pull in variables to be added to annotation
if (!is.null(groupColumn)) {
allSubsetZscoreAnnoDf <- allSubsetZscoreAnnoDf %>%
left_join(design[, c("subject", groupColumn)])
if (is.numeric(design[[groupColumn]]))
allSubsetZscoreAnnoDf <- allSubsetZscoreAnnoDf %>%
dplyr::mutate(!!rlang::sym(groupColumn) := as.character(.data[[groupColumn]]))
}
if (length(childSubsets > 0)){
if(verbose){message("No child subsets specified. Making plots for parent population only.")}
}
allSubsetZscoreAnnoDf <-
dplyr::select(allSubsetZscoreAnnoDf, all_of(annoColumns))
# set up colors as a named list
allSubsetZscoreAnnoColors <-
list(
subject = setNames(
subjectIdColors$color,
as.character(subjectIdColors$subject)
),
# assign metacluster names to colors
metacluster = metaclusterColors)
if (!is.null(groupColumn))
allSubsetZscoreAnnoColors[[groupColumn]] <- groupColors
## Use for pct rare subset color scheme
for (t in c(parentSubset, childSubsets)) {
allSubsetZscoreAnnoColors[[t]] = c(
setNames("white", 0),
setNames(colorRampPalette(c("grey95", "grey0"))(100), seq(0.01, 1.00, 0.01))
)
}
allSubsetZscoreAnno <-
ComplexHeatmap::HeatmapAnnotation(
df =
allSubsetZscoreAnnoDf %>%
mutate(across(.cols = all_of(subsets), .fns = function(val) {ifelse(is.na(val), 0, val)})),
col = allSubsetZscoreAnnoColors,
show_annotation_name = T,
show_legend =
# c(FALSE, TRUE, TRUE, rep(FALSE, times = length(subsets)))
c(FALSE, # for subject labels
TRUE, # for metacluster labels,
rep(TRUE, times = length(groupColumn)), # for group variable
rep(FALSE, times = length(subsets)) # for populations
)
)
# translate rownames
if (is.null(rowNameTranslator))
rowNameTranslator <-
setNames(markers, markers)
zscore_hmap <-
ComplexHeatmap::Heatmap(
as.matrix(experiment$allSubsetAllSubjectZscores[markers,]),
col = palZscores,
name = "z-score",
# column styling
column_title = paste0("Cluster Phenotypes from All Samples"),
column_title_gp = titleFontParam,
column_dend_height = unit(columnDendHeight, "mm"),
clustering_method_columns = experiment$linkage,
show_column_names = FALSE,
# row styling
# cluster_rows = TRUE, # don't include this, in order to allow specifying marker order
clustering_method_rows = experiment$linkage,
row_dend_width = unit(rowDendWidth, "mm"),
row_names_gp = marker_label_gp,
row_labels = rowNameTranslator[markers],
# overall styling
top_annotation = allSubsetZscoreAnno,
heatmap_legend_param = zScoreLegendParam,
...
)
return(zscore_hmap)
}
# Chunk 12: setupPalettesAndNameTranslators
PAL_DONOR_ID <-
big_colorblind_pal(
n_distinct(design$donorId),
shuffle_colors = TRUE,
drop_yellow = TRUE, drop_black = TRUE) %>%
setNames(
design %>%
dplyr::pull(donorId) %>%
unique() %>%
str_sort(numeric = TRUE))
PAL_SEX <-
c("Female"="orange", "Male"="blue")
PAL_CELL_SUBSET <-
big_colorblind_pal(nlevels(design$cellSubset), drop_yellow = TRUE, drop_black = TRUE) %>%
setNames(levels(design$cellSubset))
# color palette for plotting gene counts, e.g. on tSNE and UMAP plots
colsGeneCounts <- c("gray90", "darkred")
colsGeneCountsDiverging <- c("blue", "gray90", "red")
# set default resolution for raster layers
rasterResolutionDpi <- 300
# create name translator for markers
translatorMarkerNames <-
markerInfoV1 %>%
dplyr::select(
marker = fixed,
useToCluster) %>%
mutate(
displayName =
marker %>%
str_remove("^X(?=[0-9])") %>%
str_replace("IgGA2", "IgA2"))
palMetacluster <-
# big_colorblind_pal(
#   n_colors = nMetaclustersMax, shuffle_colors = TRUE, drop_yellow = FALSE) %>%
# ggthemes::tableau_color_pal(palette = "Tableau 10", direction = 1)(nMetaclustersMax) %>%
ggthemes::tableau_color_pal(palette = "Tableau 20", direction = 1)(nMetaclustersMax) %>%
setNames(as.character(1:nMetaclustersMax))
# Chunk 13: plotHistogramNEvents
plot.tmp <-
ggplot(design, aes(x = nEvents)) +
geom_histogram(bins = 30, color = "black", fill = "gray70") +
facet_wrap(~cellSubset, scales = "free", nrow = 2) +
xlim(0, NA) +
xlab("Number of events")
outputPlots(
plot.tmp,
fileDir = DIR_PLOTS,
fileStem = paste0("plotHistogramNEvents.", FILENAME_SUFFIX),
plotFormat = "plotscalePdf",
width = 6, height = 4,
overwrite = OVERWRITE_EXISTING_OUTPUTS)
rm_tmp(ask = FALSE)
# Chunk 14: calcTotalEventsByThreshold
thresholdRange.tmp <- c(5000, 10000, 25000, 50000, 100000, Inf)
totalEventsByThreshold <-
data.frame(threshold = thresholdRange.tmp, totalEvents = NA_real_)
# for each threshold value, sum the number of cells with each file capped at the threshold
for (threshold.tmp in thresholdRange.tmp) {
totalEventsByThreshold$totalEvents[totalEventsByThreshold$threshold == threshold.tmp] <-
sum(pmin(design$nEvents, threshold.tmp))
}
totalEventsByThreshold$propTotalEvents <-
totalEventsByThreshold$totalEvents / sum(design$nEvents)
library(kableExtra)
knitr::kable(totalEventsByThreshold) %>%
kable_styling()
# Chunk 15: setDownsampleMaxNEvents
downsampleMaxNEvents <- 10000
# Chunk 16: downsampleFcsFiles
fcsDownsampleResult <-
briDiscovr::downsampleFcsList(
fcsInfoOutfile,
maxEvents = downsampleMaxNEvents,
downsampleMode = "storeVectors",
seed = 1234)
# Chunk 17: setupDiscovrExperiment
filenameDiscovrExperiment <-
file.path(DIR_DATA_DISCOVR_TEMP_OBJ,
paste0("discovrExperiment.", FILENAME_SUFFIX, ".RDS"))
# run if not already saved
if (!file.exists(filenameDiscovrExperiment) | OVERWRITE_EXISTING_INTERMEDIATES) {
gc() # perform a garbage cleanup before running to free up unused memory
discovrSleBCells <-
setupDiscovrExperiment(
markerInfoFile = markerInfoOutfileV2,
fcsInfoFile = fcsInfoOutfile,
parentPopulation = popParent,
arcsinhA = 0,
arcsinhB = 0.2, # 0.2 for CyTof, 1/150 for flow
arcsinhC = 0,
downsampleVectorList = fcsDownsampleResult)
# save object for downstream use / loading
saveRDS(discovrSleBCells, filenameDiscovrExperiment)
} else {
# load file if already run
discovrSleBCells <- readRDS(filenameDiscovrExperiment)
}
# # do something here to compare previous to new version
# discovrSleBCellsNew <-
#   setupDiscovrExperimentNew(
#     markerInfoFile = markerInfoOutfileV2,
#     fcsInfoFile = fcsInfoOutfile,
#     parentPopulation = popParent,
#     arcsinhA = 0,
#     arcsinhB = 0.2, # 0.2 for CyTof, 1/150 for flow
#     arcsinhC = 0,
#     downsampleVectorList = fcsDownsampleResult)
# identical(discovrSleBCells, discovrSleBCellsNew)
# perform a garbage collection to free up memory
gc()
# Chunk 18: normalizeMergedData
# normalize each clustering marker (should I normalize all markers?)
# using this explicit approach rather than across() because scale returns a matrix
filenameNormalizedMergedData <-
file.path(DIR_DATA_DISCOVR_TEMP_OBJ,
paste0("normalizedMergedData.", FILENAME_SUFFIX, ".RDS"))
# run if not already saved
if (!file.exists(filenameNormalizedMergedData) | OVERWRITE_EXISTING_INTERMEDIATES) {
dataNormalizedMerged <-
discovrSleBCells$mergedExpr %>%
# group by subject
group_by(samp) %>%
mutate(
# cell-specific identifier for later use
samp_cell = paste(samp, 1:n(), sep="_"),
# z-score each marker within each sample
across(
.cols = any_of(discovrSleBCells$markerInfo$commonMarkerName),
.fns = ~ scale(.x, center = TRUE, scale = TRUE)[,1])
) %>%
ungroup()
# save object for downstream use / loading
saveRDS(dataNormalizedMerged, filenameNormalizedMergedData)
} else {
# load file if already run
dataNormalizedMerged <- readRDS(filenameNormalizedMergedData)
}
# perform a garbage collection to free up memory
gc()
# Chunk 19: plotDensityMergedExprPrePostNormalizationBySample
filename.tmp <-
file.path(
"plots",
paste0("plotDensityMergedExprPrePostNormalizationBySample.",
FILENAME_SUFFIX, ".pdf"))
# these plots are time-consuming to generate, so skip if already created
if (!file.exists(filename.tmp) | OVERWRITE_EXISTING_OUTPUTS) {
# set limit for min and max z-scores to show in plot (should investigate values beyond these)
zScoreLimit.tmp <- c(-5, 5)
data.tmp <-
bind_rows(
discovrSleBCells$mergedExpr %>%
mutate(status = "arcsinh-transformed"),
dataNormalizedMerged %>%
mutate(
# trim values beyond a certain limit of z-scores, for easier visualization
across(any_of(discovrSleBCells$markerInfo$commonMarkerName),
.fns =  \(x) ifelse(x %outside% zScoreLimit.tmp, NA_real_, x)),
status = "z-score normalized"))
pdf(
filename.tmp,
width = 12, height = 6)
for (marker.tmp in
c(markerInfoV2$fixed[markerInfoV2$useToCluster],
markerInfoV2$fixed[!markerInfoV2$useToCluster])) {
if (marker.tmp %nin% colnames(data.tmp)) next
plot.tmp <-
ggplot(
data.tmp,
mapping = aes(x = !!rlang::sym(marker.tmp), group = samp)) +
geom_density(linewidth = 0.2, alpha = 0.5, color = "gray50") +
facet_wrap(~status, scales = "free") +
labs(
x =
paste0(
translatorMarkerNames$displayName[match(marker.tmp, translatorMarkerNames$marker)],
" intensity\n(", if(!markerInfoV2$useToCluster[markerInfoV2$fixed == marker.tmp]) "not ",
"used in clustering)")) +
guides(color = guide_legend(override.aes = list(linewidth = 3)))
print(plot.tmp)
}
invisible(dev.off())
}
rm_tmp(ask = FALSE)
# Chunk 20: removeDataNormalizedMerged
# remove this large object, and perform a garbage collection
rm(dataNormalizedMerged)
gc()
discovrSleBCellsClustered <-
clusterDiscovrExperiment(discovrSleBCells, seed = 12345)
# setwd("~/Box Sync/Tools/R_scripts/R_packages")
library(devtools)
library(roxygen2)
packagesDirectory <-
file.path("~", "Library", "CloudStorage", "Box-Box",
"Tools", "R_scripts", "R_packages")
packageName <- "briDiscovr"
wd.tmp <- getwd()
setwd(file.path(packagesDirectory, packageName))
# usethis::create_package(packageName)  # initial package creation
devtools::document()
credentials::set_github_pat()
rm(list = ls())
str_match
devtools::install(file.path("..", packageName))
# setwd("~/Box Sync/Tools/R_scripts/R_packages")
library(devtools)
library(roxygen2)
packagesDirectory <-
file.path("~", "Library", "CloudStorage", "Box-Box",
"Tools", "R_scripts", "R_packages")
packageName <- "briDiscovr"
wd.tmp <- getwd()
setwd(file.path(packagesDirectory, packageName))
# usethis::create_package(packageName)  # initial package creation
devtools::document()
credentials::set_github_pat()
devtools::install(file.path("..", packageName))
