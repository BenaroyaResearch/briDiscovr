% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/exportedUtils.R
\name{runUmapDiscovrExperiment}
\alias{runUmapDiscovrExperiment}
\title{Calculate UMAP coordinates for the cells from a discovrExperiment object}
\usage{
runUmapDiscovrExperiment(
  experiment,
  umapMarkers = NULL,
  downsampleBy = "frequency",
  downsampleFreq = c(parentPopulation = 100, childPopulations = 1),
  downsampleNumber = c(parentPopulation = 100, childPopulations = Inf),
  normalizationInfo = NULL,
  seed = NULL,
  returnUmapObject = FALSE,
  returnExpressionNormalizedScaled = FALSE,
  ...
)
}
\arguments{
\item{experiment}{A discovrExperiment created using
\code{setupDiscovrExperiment}, \code{clusterDiscovrExperiment},
\code{normalizeDiscovrExperiment}, or \code{metaclusterDiscovrExperiment}.
In order to return metacluster numbers for each cell, its status must be
"metaclustered". If normalization has not already been run, it will be run
using \code{normalizeDiscovrExperiment} prior to running UMAP.}

\item{umapMarkers}{A character vector, the markers to be used for UMAP. For
the default value, NULL, the function extracts the set of markers from the
"clusteringMarkers" element of the discovrExperiment object.}

\item{downsampleBy}{character, specifying which downsampling method to use.
Acceptable values are "frequency", "number", or unique partial matches.
Defaults to "frequency" to replicate behavior of earlier versions. With
method "frequency", the cells from each sample are trimmed to keep 1 cell
for every N cells in the sample. With method "number", the cells are trimmed
to keep up to N cells from each sample. If "frequency" is used, the
"downsampleFreq" parameter is required and "downsampleNumber" will be
ignored. Similarly, if "number" is used, the "downsampleNumber" parameter is
required and "downsampleFreq" will be ignored.}

\item{downsampleFreq}{numeric, specifying how to downsample the cells prior
to running UMAP. This approach keeps 1 cell for every N total cells in each
population in each sample. Several alternative methods can be used by providing
different numeric vectors. If a single value is provided, all
populations are downsampled to this frequency. If a vector of length 2 is
provided (optionally with elements named "parentPopulation" and
"childPopulations"), the "parentPopulation" or first element is used as the
frequency for the parent population (extracted from the discovrExperiment
object), and the "childPopulations" or second element is used as the
frequency for the child populations. If a named vector is provided, the names
must match the cell populations, and the values are the frequencies
to downsample each population to. If NULL, no downsampling is performed. The
default is c("parentPopulation" = 100, "childPopulations" = 1), which retains
all cells from child populations and subsets the parent population to 1/100.
Note that downsampling is based on the order of the cells in
discovrExperiment, so changes that alter the order of cells will make the
downsampling results non-reproducible.}

\item{downsampleNumber}{numeric, specifying how to downsample the cells
prior to running UMAP. This approach keeps up to N cells for each population
in each sample. Several alternative methods can be used by providing
different numeric vectors. If a single value is provided, all populations
are downsampled to this number of cells. If a vector of length 2 is provided
(optionally with elements named "parentPopulation" and "childPopulations"),
the "parentPopulation" or first element is used as the number for the parent
population (extracted from the discovrExperiment object), and the
"childPopulations" or second element is used as the number for the child
populations. If a named vector is provided, the names must match the cell
populations, and the values are the numbers to downsample each population
to. If NULL, no downsampling is performed. To keep all cells in a population,
set to Inf. The default is c("parentPopulation" = 100, "childPopulations" =
Inf), which retains all cells from child populations and subsets the parent
population to 100 cells. Note that downsampling is based on the order of the
cells in discovrExperiment, so changes that alter the order of cells will
make the downsampling results non-reproducible.}

\item{normalizationInfo}{(default: NULL) character string or vector
specifying normalization method to be applied, passed to
\code{normalizeDiscovrExperiment}. NOTE: if this argument is non-null,
the specified normalization will be applied to the input 'experiment', even
if that object has already had normalization applied. Thus, including a
non-null value here will override any existing normalization prior to
running UMAP.}

\item{seed}{(default: NULL) numeric, the seed to be passed to 
\code{set.seed} to make the UMAP (more) reproducible. If NULL, no seed is set.}

\item{returnUmapObject}{(default: FALSE) logical, if TRUE, returns the full
UMAP output object and the data frame of cell information as a list. If
FALSE, returns only the data frame of cell information.}

\item{returnExpressionNormalizedScaled}{(default: FALSE) logical, if TRUE,
includes the normalized, scaled expression values for the markers used in the
UMAP in the output data frame. If FALSE, the data frame only contains the
UMAP coordinates and cell information.}

\item{...}{optional arguments passed to \code{umap::umap}.}
}
\value{
A data frame containing the UMAP coordinates for each cell, as columns
'UMAP1' and 'UMAP2', and the original cell population and sample information.
The data frame also contains the metacluster information, if available.
If \code{returnUmapObject} is TRUE, returns a list with the data frame of
cell information as element 'data' and the UMAP output object as element
'umapObject'.
If \code{returnExpressionNormalizedScaled} is TRUE, the data frame also
contains the z-scored expression values for the markers used in the UMAP.
}
\description{
This function generates a UMAP from the cells in a discovrExperiment object.
To do this, it extracts the marker scores for each cells, z-scores the
expression values within each sample (similar to the briDiscovr
metaclustering process), optionally downsamples the cells to speed the
process (with downsampling frequency tunable at the cell population level),
and then runs the UMAP algorithm. The UMAP algorithm is run using the
\code{umap} package, which is a wrapper for the \code{uwot} package. Results
can be made reproducible by passing a non-NULL value for \code{seed}. This
function returns a data frame with the UMAP coordinates for each cell, as
well as the original cell population, sample information, and metacluster if
available. The outputs are intended to be visualized using plotting software
such as ggplot2.
}
\author{
Matthew J Dufort, \email{mdufort@benaroyaresearch.org}
}
